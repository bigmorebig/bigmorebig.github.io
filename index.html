<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    fancybox: false,
    mediumzoom: false,
    fastclick: false,
    lazyload: false,
    pangu: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="进击的测试">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://github.com/bigmorebig/bigmorebig.github.io/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="进击的测试">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的博客">
<meta name="twitter:description" content="进击的测试">



  <link rel="alternate" href="/atom.xml" title="我的博客" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://github.com/bigmorebig/bigmorebig.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>我的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-list"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-history"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/12/04/多线程与多进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/04/多线程与多进程/" class="post-title-link" itemprop="url">多线程与多进程</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-04 20:16:50 / 修改时间：20:17:16" itemprop="dateCreated datePublished" datetime="2019-12-04T20:16:50+08:00">2019-12-04</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="gil锁"><a href="#gil锁" class="headerlink" title="gil锁"></a>gil锁</h3><blockquote>
<p>本文中的python都指cpython</p>
</blockquote>
<p>gil全称为global interpreter lock，python中的一个线程分别对应c语言中的一个线程。GIL的存在使得同一时刻只能有一个线程在CPU上执行字节码，这就意味着不能像其他编程语言一样将多个线程映射到多个CPU上以实现真正的并发编程</p>
<p>所以GIL锁的存在使得python真正的并发编程成为一种奢望，但可以在一个CPU上快速的切换线程，已达到类并发的效果，以减少线程的等待时间。</p>
<p>GIL锁是可以释放的，满足以下任一条件都可以释放GIL锁</p>
<ul>
<li>GIL会在执行的时间片满了或者字节数满了之后释放GIL锁</li>
<li>在遇到IO操作时会释放锁</li>
</ul>
<p>多线程演变的原因在于：进程对系统资源的消耗巨大，其次进程间相互隔离。但是对于文件IO操作，多线程和多进程性能差别不大，甚至多进程的速度会比多线程稍快</p>
<p>每个多线程启动时，都会存在一个主线程<code>main thread</code>，默认主线程退出时，子线程会被kill掉，所以<code>threading</code>模块中提供的<code>join</code>函数，手动将子线程挂起，待子线程执行完之后再执行主线程</p>
<p>Thread提供了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">	time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">	thread1 = threading.Thread(target=test1)</span><br><span class="line">	thread2 = threading.Thread(target=test2)</span><br><span class="line">	start = time.time()</span><br><span class="line">	thread1.start()</span><br><span class="line">	thread2.start()</span><br><span class="line">	print(<span class="string">'total time spend: &#123;&#125;'</span>.format(time.time() - start))</span><br><span class="line"><span class="comment">## output:total time spend: 0.0</span></span><br></pre></td></tr></table></figure>

<p>如果加上<code>join</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print(<span class="string">'total time spend: &#123;&#125;'</span>.format(time.time() - start))</span><br><span class="line"><span class="comment">## output:total time spend: 3.00200009346</span></span><br></pre></td></tr></table></figure>

<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>线程间通信可通过以下两种方式</p>
<ol>
<li>全局变量</li>
<li>队列通信</li>
</ol>
<p>利用全局变量<code>global</code>可方便实现多线程之间通信，但是由于GIL锁的存在，可能会造成由于线程的时间片或者字节数满了，而造成线程间切换，而带来数据丢失</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        a += i</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        a -= i</span><br><span class="line">thread1 = threading.Thread(target=add, args=(<span class="number">1000000</span>, ))</span><br><span class="line">thread2 = threading.Thread(target=sub, args=(<span class="number">1000000</span>, ))</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># output: -262517192310</span></span><br></pre></td></tr></table></figure>

<p>当然，可以通过加锁的方式来保证线程的安全，随之带来的是线程性能的下降，所以可通过<code>queue</code>的方式来进行线程间的通信</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num, queue)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        queue.put(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(num, queue)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        queue.get(num)</span><br><span class="line"></span><br><span class="line">queue = Queue(maxsize=<span class="number">100</span>)</span><br><span class="line">thread1 = threading.Thread(target=add, args=(<span class="number">1000000</span>, queue))</span><br><span class="line">thread2 = threading.Thread(target=sub, args=(<span class="number">1000000</span>, queue))</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print(queue.qsize())</span><br><span class="line"><span class="comment"># output: 0</span></span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，Queue的get和put方法中，还是使用的锁，都是使用的，通过查看put源码，可发现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> self.not_full:</span><br><span class="line">    <span class="keyword">if</span> self.maxsize &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> block:</span><br><span class="line">            <span class="keyword">if</span> self._qsize() &gt;= self.maxsize:</span><br><span class="line">                <span class="keyword">raise</span> Full</span><br><span class="line">        <span class="keyword">elif</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> self._qsize() &gt;= self.maxsize:</span><br><span class="line">                self.not_full.wait()</span><br><span class="line">        <span class="keyword">elif</span> timeout &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"'timeout' must be a non-negative number"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            endtime = time() + timeout</span><br><span class="line">            <span class="keyword">while</span> self._qsize() &gt;= self.maxsize:</span><br><span class="line">                remaining = endtime - time()</span><br><span class="line">                <span class="keyword">if</span> remaining &lt;= <span class="number">0.0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Full</span><br><span class="line">                self.not_full.wait(remaining)</span><br><span class="line">    self._put(item)</span><br><span class="line">    self.unfinished_tasks += <span class="number">1</span></span><br><span class="line">    self.not_empty.notify()</span><br></pre></td></tr></table></figure>

<p>当队列不为空，阻塞时，队列会等待放数据，然后通知下一个线程</p>
<p>与全局变量相比，队列安全，方便，开箱即用。当然，队列也存在性能方便的问题，加锁之后，性能下降是无法避免的。Queue可指定队列的<code>maxsize</code>参数，因为maxsize过大会占用过多内存，所以使用时最好指定合适的大小。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>线程同步我理解的是用来保证线程安全的方式，一般来说线程同步有三种方式，分别如下</p>
<ol>
<li>Lock，加锁</li>
<li>RLock，也是加锁，只是可重入的锁</li>
<li>Condition，复杂线程同步</li>
</ol>
<p>还是回到之前说的全局变量的那个例子中，为了更好的展示python中字节码的接在过程，使用如下例子演示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a)</span>:</span></span><br><span class="line">    a +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(a)</span>:</span></span><br><span class="line">    a -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(dis.dis(add))</span><br><span class="line">print(dis.dis(sub))</span><br><span class="line"><span class="comment">#  7           0 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="comment">#              2 LOAD_CONST               1 (1)</span></span><br><span class="line"><span class="comment">#              4 INPLACE_ADD</span></span><br><span class="line"><span class="comment">#              6 STORE_FAST               0 (a)</span></span><br><span class="line"><span class="comment">#              8 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="comment">#             10 RETURN_VALUE</span></span><br><span class="line"><span class="comment">#None</span></span><br><span class="line"><span class="comment"># 10           0 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="comment">#              2 LOAD_CONST               1 (1)</span></span><br><span class="line"><span class="comment">#              4 INPLACE_SUBTRACT</span></span><br><span class="line"><span class="comment">#              6 STORE_FAST               0 (a)</span></span><br><span class="line"><span class="comment">#              8 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="comment">#             10 RETURN_VALUE</span></span><br><span class="line"><span class="comment">#None</span></span><br></pre></td></tr></table></figure>

<p>由于GIL的存在，这两个函数在使用多线程的时候，有可能会存在以下的情况：先加载add中的a，在加载sub中的a；加载add中的1，再加载sub中的1；add中+运算，sub中-运算；add中赋值操作，sub中赋值操作。由此，得出来最后的结果为-1，而不是0。</p>
<p>为了解决以上问题，先试试Lock，执行部分代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">lock.acquire()</span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">lock.release()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>acquire</code>是为这个线程加上一把锁，<code>release</code>是释放这个线程的锁，需要注意的是，当前的线程必须要释放掉当前的这把锁之后才能进行下一步，于是就带来了Lock最大的弊端，容易<strong>死锁</strong></p>
<p>于是，由于Lock的存在，带来了RLock，可重入的锁，这可以连续多次调用<code>acquire</code>，只要保证一个线程中的acquire和release个数是相同的，就不会造成死锁，这就为多线程之间相互调用提供了可能，比较方便的是，RLock和Lock的接口一致性，也是使用的<code>acquire</code>和<code>release</code></p>
<p>但是对于复杂场景下的线程同步，这两种锁显然满足不了需求，比如，多个线程之间的对话。为了解决这种机制问题，可使用Condition模块，condition会先执行该线程之后，会使用notify方法通知另外一个线程，并且使用wait方法等待另外一个线程的通知，这种情况下线程启动的先后顺序就显得尤为重要了。由此种机制可以理解，这其实也是用的锁，由Condition的源码也可以看见，<code>__init__</code>构造函数中还是加了一把锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> lock <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	lock = RLock()</span><br><span class="line">self._lock = lock</span><br></pre></td></tr></table></figure>

<p>而由于condition中实现了<code>__enter__</code>和<code>__exit__</code>，而这两个方法底层调用的是RLock中的<code>__enter__</code>和<code>__exit__</code>，而RLock中的这两个方法是调用的<code>acquire</code>和<code>lock</code>方法，于是RLock中的加锁和取锁可以简化为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">	a -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say1</span><span class="params">(cond)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        cond.wait()</span><br><span class="line">        print(<span class="string">'say 1'</span>)</span><br><span class="line">        cond.notify()</span><br><span class="line"></span><br><span class="line">        cond.wait()</span><br><span class="line">        print(<span class="string">'say 2'</span>)</span><br><span class="line">        cond.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say3</span><span class="params">(cond)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        print(<span class="string">'say 3'</span>)</span><br><span class="line">        cond.notify()</span><br><span class="line">        cond.wait()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'say 4'</span>)</span><br><span class="line">        cond.notify()</span><br><span class="line">        cond.wait()</span><br><span class="line">cond = threading.Condition()</span><br><span class="line">threading.Condition()</span><br><span class="line">thread1 = threading.Thread(target=say1, args=(cond, ))</span><br><span class="line">thread2 = threading.Thread(target=say3, args=(cond, ))</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"><span class="comment"># say 3</span></span><br><span class="line"><span class="comment"># say 1</span></span><br><span class="line"><span class="comment"># say 4</span></span><br><span class="line"><span class="comment"># say 2</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>wait</code>方法调用时，会先释放底层锁，然后阻塞，直到另一个线程调用notify()或者notify_all()方法为止，或者timeout超时为止，当被唤醒或者超时，它将重新获得锁并返回</p>
<p>在web开发中，通常会使用限制同时爬取的线程个数来控制反爬，在多线程中，可通过<code>Semaphore</code>方法来实现，例子如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetUrlList</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sem)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            detail_html = ParseDetail(<span class="string">'https://www.baidu.com/&#123;&#125;'</span>.format(i), self.sem)</span><br><span class="line">            detail_html.start()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParseDetail</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, sem)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line">        self.url = url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'parse html success'</span>)</span><br><span class="line">        self.sem.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sem = threading.Semaphore(<span class="number">3</span>)</span><br><span class="line">    url_list = GetUrlList(sem)</span><br><span class="line">    url_list.start()</span><br></pre></td></tr></table></figure>

<p><code>Semaphore</code>默认的线程个数为1个，可自行指定个数，需要注意的是，acquire和release方法中还是用的condition的锁</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>对于多线程的线程池，Semaphore其实可以作为是一个简易的线程池，但是遇到复杂场景下，它不能很好的处理，比如：主线程获取某一个线程或者任务的状态和返回值；当一个线程执行完之后能马上通知主线程并返回。</p>
<p>这时，就需要通过另外的方法了，由此引申出concurrent模块的<code>futures</code>方法，其中的<code>ThreadPoolExecutor</code>方法封装了对于多线程的各种复杂方法，且与多进程的接口一致性，用来保证可复用性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(sec)</span>:</span></span><br><span class="line">    print(<span class="string">'i sleep &#123;&#125; sec'</span>.format(sec))</span><br><span class="line">    time.sleep(sec)</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">task1 = executor.submit(sleep, <span class="number">2</span>)</span><br><span class="line">task2 = executor.submit(sleep, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><code>submit</code>方法会在线程执的时候立即返回，如上例，会先打印字符串，再等待几秒</p>
<p><code>done</code>方法会返回当前线程是否已经执行完成，完成返回True，否则为False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task1 = executor.submit(sleep, <span class="number">2</span>)</span><br><span class="line">task2 = executor.submit(sleep, <span class="number">3</span>)</span><br><span class="line">print(task1.done())</span><br><span class="line"><span class="comment">#output: False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task1 = executor.submit(sleep, <span class="number">2</span>)</span><br><span class="line">task2 = executor.submit(sleep, <span class="number">3</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">print(task1.done())</span><br><span class="line"><span class="comment">#output: True</span></span><br></pre></td></tr></table></figure>

<p><code>result</code>方法可以获取线程的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(task1.result())</span><br></pre></td></tr></table></figure>

<p>如果想要获取已经成功完成的返回结果，可以通过<code>futures</code>模块下的<code>as_completed</code>方法获取，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line">...</span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">secs = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">tasks = [executor.submit(sleep, sec) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed(tasks):</span><br><span class="line">    data = future.result()</span><br><span class="line">    print(<span class="string">'this is &#123;&#125; sec'</span>.format(data))</span><br><span class="line"><span class="comment"># i sleep 3 sec</span></span><br><span class="line"><span class="comment"># i sleep 2 sec</span></span><br><span class="line"><span class="comment"># i sleep 4 sec</span></span><br><span class="line"><span class="comment"># this is 2 sec</span></span><br><span class="line"><span class="comment"># this is 3 sec</span></span><br><span class="line"><span class="comment"># this is 4 sec</span></span><br></pre></td></tr></table></figure>

<p>它的特点是先完成先返回，比如上例中，先返回2秒的线程，最后返回4秒的线程</p>
<p>此外，还提供了一种更为简便的方法，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> executor.map(sleep, secs):</span><br><span class="line">    print(<span class="string">'this is &#123;&#125; sec'</span>.format(data))</span><br><span class="line"><span class="comment">#i sleep 3 sec</span></span><br><span class="line"><span class="comment">#i sleep 2 sec</span></span><br><span class="line"><span class="comment">#i sleep 4 sec</span></span><br><span class="line"><span class="comment">#this is 3 sec</span></span><br><span class="line"><span class="comment">#this is 2 sec</span></span><br><span class="line"><span class="comment">#this is 4 sec</span></span><br></pre></td></tr></table></figure>

<p>它与<code>as_completed</code>方法存在些许不同，map方法的执行顺序是按照可迭代对象的顺序执行，as_completed执行顺序是按照线程完成的先后顺序执行，在使用的时候需注意这点。</p>
<h3 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h3><p>由于GIL锁的存在，多线程不能有效的利用多核的CPU，从而没办法达到真正的并发操作，python中所谓的多线程其实是快速的切换同一个CPU而已，只是在多个线程可能存在的网络延迟，程序处理中，还是很有必要的。相比之下，多进程能实现真正的并发编程，能使用多个CPU同时工作，但是，进程间资源不共享，进程切换带来的巨大消耗，使得多进程编程无法成为大多数并发编程的主流。于是，综合以上，得出以下经验</p>
<ol>
<li>对于消耗CPU资源大的操作，可尽量使用多进程编程，例如，算术操作</li>
<li>对于IO频繁的操作，尽量使用多线程编程</li>
</ol>
<p>在多进程中，通常使用<code>futures</code>模块中的<code>ProcessPoolExecutor</code>方法，因为该方法具有与<code>ThreadPoolExecutor</code>的多线程编程的一致接口，换个名字即可，在此不做过多示例，但是必须注意的是，在使用该方法时，必须将多进程相关操作放在<code>if __name__ == &#39;__main__&#39;:</code>之后(windows平台)。</p>
<p>以下多进程相关操作，都是用<code>multiprocessing</code>模块演示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(sec)</span>:</span></span><br><span class="line">    time.sleep(sec)</span><br><span class="line">    print(<span class="string">'i sleep &#123;&#125; sec'</span>.format(sec))</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = multiprocessing.Process(target=sleep, args=(<span class="number">2</span>, ))</span><br><span class="line">    p2 = multiprocessing.Process(target=sleep, args=(<span class="number">3</span>, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br></pre></td></tr></table></figure>

<p>操作与<code>threading</code>模块中多线程的操作类似</p>
<p>可使用<code>multiprocessing</code>模块下的<code>Pool</code>方法来设定进程池，且进程池默认为当前CPU的个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">result1 = pool.apply_async(sleep, args=(<span class="number">2</span>, ))</span><br><span class="line">result2 = pool.apply_async(sleep, args=(<span class="number">3</span>, ))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:必须先关闭pool，再挂起pool</p>
</blockquote>
<p>如果想要获取进程执行结果，可使用<code>get</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(result1.get())</span><br></pre></td></tr></table></figure>

<p>进程池还提供了<code>imap</code>方法，类似于<code>executor.map()</code>的功能，执行的顺序与传递的可迭代对象的顺序相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> pool.imap(sleep, [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]):</span><br><span class="line">	print(data)</span><br><span class="line"><span class="comment">#i sleep 2 sec</span></span><br><span class="line"><span class="comment">#i sleep 3 sec</span></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment">#i sleep 4 sec</span></span><br><span class="line"><span class="comment">#4</span></span><br></pre></td></tr></table></figure>

<p>此外，还提供了<code>map</code>方法，类似于<code>as_completed</code>方法，执行的顺序按照时间先后顺序，在此不再赘述</p>
<h3 id="多进程间通信"><a href="#多进程间通信" class="headerlink" title="多进程间通信"></a>多进程间通信</h3><p>由于进程间资源是不共享的，所以多进程通信无法使用全局变量，可使用以下方式来进行通信</p>
<ul>
<li>使用<code>multiprocessing</code>模块下的<code>Queue</code>方法来进行通信，却无法使用之前使用的原生<code>Queue</code>来进行通信，但是此方法无法在进程池中使用</li>
<li>进程池下的通信可使用<code>multiprocessing</code>模块下的<code>Manager</code>方法来进行通信(<code>Manager().Queue()</code>)</li>
<li>使用<code>pipe</code>管道进行通信</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(queue)</span>:</span></span><br><span class="line">    data = queue.get(<span class="string">'a'</span>)</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue(<span class="number">100</span>)</span><br><span class="line">    p1 = multiprocessing.Process(target=add, args=(queue, ))</span><br><span class="line">    p2 = multiprocessing.Process(target=sub, args=(queue, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line"><span class="comment">#output: a</span></span><br></pre></td></tr></table></figure>

<p>进程池通信</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue = Manager().Queue(<span class="number">100</span>)</span><br><span class="line">pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">pool.apply_async(add, args=(queue, ))</span><br><span class="line">pool.apply_async(sub, args=(queue, ))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"><span class="comment">#output: a</span></span><br></pre></td></tr></table></figure>

<p>管道通信</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(<span class="string">'jack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    data = pipe.recv()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line">    p1 = multiprocessing.Process(target=add, args=(send_pipe, ))</span><br><span class="line">    p2 = multiprocessing.Process(target=sub, args=(recevie_pipe, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line"><span class="comment">#output: jack</span></span><br></pre></td></tr></table></figure>

<p>管道通信只能应用于两个进程之间，并且它的性能要高于使用Queue，原因在于队列使用了很多锁，这会带来性能的下降</p>
<h3 id="进程间内存共享"><a href="#进程间内存共享" class="headerlink" title="进程间内存共享"></a>进程间内存共享</h3><p>有些时候我们需要使用多个进程对同一个内存空间进行操作，比如，多个进程修改同一个字典。<code>multiprocessing</code>模块中的<code>Manager</code>方法提供了丰富的数据结构，以供内存共享来使用，比如常见的<code>dict</code>,<code>list</code>,<code>array</code>以及<code>Lock</code>,<code>RLock</code>,<code>Condition</code>等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_list</span><span class="params">(p_list, new)</span>:</span></span><br><span class="line">    p_list.append(new)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    process_list = Manager().list()</span><br><span class="line">    p1 = multiprocessing.Process(target=add_list, args=(process_list, <span class="string">'tang'</span>, ))</span><br><span class="line">    p2 = multiprocessing.Process(target=add_list, args=(process_list, <span class="string">'jack'</span>, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(process_list)</span><br><span class="line"><span class="comment">#output: ['tang', 'jack']</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/11/12/docker应用原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/docker应用原理/" class="post-title-link" itemprop="url">docker应用原理</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 18:23:27 / 修改时间：18:24:54" itemprop="dateCreated datePublished" datetime="2019-11-12T18:23:27+08:00">2019-11-12</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/容器与容器技术/" itemprop="url" rel="index"><span itemprop="name">容器与容器技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="使用docker部署一个python应用"><a href="#使用docker部署一个python应用" class="headerlink" title="使用docker部署一个python应用"></a>使用docker部署一个python应用</h3><p>使用到的代码如下所示，是一个典型的flask项目</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    html = <span class="string">"&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;"</span> \</span><br><span class="line">           <span class="string">"&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;"</span>           </span><br><span class="line">    <span class="keyword">return</span> html.format(name=os.getenv(<span class="string">"NAME"</span>, <span class="string">"world"</span>), hostname=socket.gethostname())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure>

<p>同时将依赖放在同目录下的<code>requirement.txt</code>的目录中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat requirements.txt</span><br><span class="line">Flask</span><br></pre></td></tr></table></figure>

<p>接下来，制作<code>Dockerfile</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方提供的Python开发镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将工作目录切换为/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下的所有内容复制到/app下</span></span><br><span class="line"><span class="keyword">ADD</span> . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pip命令安装这个应用所需要的依赖</span></span><br><span class="line"><span class="keyword">RUN</span> pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许外界访问容器的80端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器进程为：python app.py，即：这个Python应用的启动命令</span></span><br><span class="line"><span class="keyword">CMD</span> ["python", "app.py"]</span><br></pre></td></tr></table></figure>

<p>在Dockerfile中，使用一些原语来处理逻辑流程，且执行顺序是由上往下执行</p>
<p>值得一提的是，通常还会看到一个叫<code>ENTRYPOINT</code>的原语，实际上，它和<code>CMD</code>都是docker进程启动时所必需的的参数，完整的格式是<code>ENTRYPOINT CMD</code>,但是，在默认情况下，docker会提供一个默认的ENTRYPOINT参数，即<code>/bin/bash -c</code>，所以在这个例子中，实际运行的是<code>/bin/bash -c python app.py</code></p>
<p>加下来，就可以制作镜像了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker build -t helloworld .</span><br></pre></td></tr></table></figure>

<p><code>-t</code>是指加一个tag，即取一个名字，docker build会依次执行dockerfile文件，并且每一句原语会生成一层镜像。即使原语本身没有明显的修改文件操作，它回应的层也是会存在的，只不过在外界看来，这个层是空的。</p>
<h3 id="exec命令进入容器内部"><a href="#exec命令进入容器内部" class="headerlink" title="exec命令进入容器内部"></a>exec命令进入容器内部</h3><p>通过docker exec命令可以进入一个正在运行的docker容器中。</p>
<p>实际上，Linux Namespace 创建的隔离空间虽然看不见摸不着，但一个进程的 Namespace 信息在宿主机上是确确实实存在的，并且是以一个文件的方式存在。</p>
<p>通过如下指令，你可以看到当前正在运行的 Docker 容器的进程号（PID）是 25686：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker inspect --format '&#123;&#123; .State.Pid &#125;&#125;' </span><br><span class="line">4ddf4638572d25686</span><br></pre></td></tr></table></figure>

<p>这时，你可以通过查看宿主机的 proc 文件，看到这个 25686 进程的所有 Namespace 对应的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls -l  /proc/25686/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 ipc -&gt; ipc:[4026532278]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 mnt -&gt; mnt:[4026532276]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 net -&gt; net:[4026532281]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 pid -&gt; pid:[4026532279]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 pid_for_children -&gt; pid:[4026532279]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Aug 13 14:05 uts -&gt; uts:[4026532277]</span><br></pre></td></tr></table></figure>

<p>可以看到，一个进程的每种 Linux Namespace，都在它对应的 /proc/[进程号]/ns 下有一个对应的虚拟文件，并且链接到一个真实的 Namespace 文件上。这就相当于’HODL’住了所有的Namespace，那么就可以实现进入一个已经存在的Namespace中了。</p>
<p><strong>这也就意味着：一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的，这正是 docker exec 的实现原理。</strong></p>
<p>简单说下所依赖的原理，其实是依赖于<code>setns()</code>的Linux系统调用，具体用法可以百度或Google。它的作用就是加入一个进程的Namespace中。</p>
<p>docker commit，实际上就是在容器运行起来后，把最上层的“可读写层”，加上原先容器镜像的只读层，打包组成了一个新的镜像。当然，下面这些只读层在宿主机上是共享的，不会占用额外的空间。</p>
<p>由于使用了联合文件系统，容器对镜像的任何操作，都会被操作系统先复制到可读写层，然后再修改，这就是所谓的<code>Copy On Write</code>。当然，docker commit不会提交Init层的内容。</p>
<h3 id="Volume机制"><a href="#Volume机制" class="headerlink" title="Volume机制"></a>Volume机制</h3><p>volume的存在在于解决容器中文件与数据在宿主机上的备份。而volume的存在，<strong>允许将宿主机上指定的文件或目录挂载到容器中进行读取和修改。</strong></p>
<p>在docker中，有两种申明方式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -v /test ...</span><br><span class="line"><span class="meta">$</span> docker run -v /home:/test ...</span><br></pre></td></tr></table></figure>

<p>这两种命令的本质是相同的，都是把一个宿主机的目录挂载到容器的/test目录中。只是在第一种情况下，由于没有申明宿主机目录，docker会默认在宿主机创建一个临时目录<code>/var/lib/docker/volumes/[VOLUME_ID]/_data</code>，然后将它挂载到容器的/test目录下。而第二种情况，是直接将宿主机的<code>/home</code>目录挂载到容器的/test目录下。</p>
<p>由于当容器进程被创建之后，尽管开启了 Mount Namespace，但是在它执行 chroot（或者 pivot_root）之前，容器进程一直可以看到宿主机上的整个文件系统。</p>
<p>而宿主机上的文件系统，也自然包括了我们要使用的容器镜像。这个镜像的各个层，保存在 <code>/var/lib/docker/aufs/diff</code>目录下，在容器进程启动后，它们会被联合挂载在<code>/var/lib/docker/aufs/mnt/</code> 目录中，这样容器所需的 rootfs 就准备好了。</p>
<p>所以，我们只需要在 rootfs 准备好之后，在执行 chroot 之前，把 Volume 指定的宿主机目录（比如 /home 目录），挂载到指定的容器目录（比如 /test 目录）在宿主机上对应的目录（即 /var/lib/docker/aufs/mnt/[可读写层 ID]/test）上，这个 Volume 的挂载工作就完成了。</p>
<p>更重要的是，由于执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p>
<p>而这里要使用到的挂载技术，就是 Linux 的绑定挂载（bind mount）机制。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。</p>
<blockquote>
<p>注意：这里提到的 “ 容器进程 “，是 Docker 创建的一个容器初始化进程 (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根目录的准备、挂载设备和目录、配置 hostname 等一系列需要在容器内进行的初始化操作。最后，它通过 execv() 系统调用，让应用进程取代自己，成为容器里的 PID=1 的进程。</p>
</blockquote>
<p><strong>所以，在一个正确的时机，进行一次绑定挂载，Docker 就可以成功地将一个宿主机上的目录或文件，不动声色地挂载到容器中。</strong></p>
<p>同时，/test目录中的内容，也不会被docker commit所提交。原因在于，容器的镜像操作，比如 docker commit，都是发生在宿主机空间的。而由于 Mount Namespace 的隔离作用，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的 /test 目录（/var/lib/docker/aufs/mnt/[可读写层 ID]/test），始终是空的。</p>
<p>以上，就是docker volume的核心原理了。</p>
<p>总结一下，将rootfs分层所示如下图</p>
<p><img src="/images/rootfs.png" alt="docker分层"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><p><a href="https://time.geekbang.org/column/article/18119" target="_blank" rel="noopener">https://time.geekbang.org/column/article/18119</a></p>
</li>
<li><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p>
</li>
</ol>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/11/07/容器技术的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/07/容器技术的实现/" class="post-title-link" itemprop="url">容器技术的实现</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-07 18:10:11 / 修改时间：19:10:17" itemprop="dateCreated datePublished" datetime="2019-11-07T18:10:11+08:00">2019-11-07</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/容器与容器技术/" itemprop="url" rel="index"><span itemprop="name">容器与容器技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="容器技术的兴起"><a href="#容器技术的兴起" class="headerlink" title="容器技术的兴起"></a>容器技术的兴起</h3><ul>
<li>容器技术的兴起源于<a href="https://www.ibm.com/support/knowledgecenter/SSTTDS_11.0.0/com.ibm.etools.mft.doc/cf10009_.htm" target="_blank" rel="noopener">PaSS</a>技术的普及</li>
<li>Docker公司发布的Docker项目具有里程碑式的意义</li>
<li>Docker项目通过“容器镜像”，解决了应用打包的根本性难题</li>
</ul>
<h3 id="NameSpace隔离"><a href="#NameSpace隔离" class="headerlink" title="NameSpace隔离"></a>NameSpace隔离</h3><p>我们经常看见一张对比虚拟机和Docker的图<img src="/images/docker_VS_%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="虚拟机 VS Docker"></p>
<p>这幅图的左边，画出了虚拟机的工作原理。其中，名为 <code>Hypervisor</code>的软件是虚拟机最主要的部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。</p>
<p>而这幅图的右边，则用一个名为 Docker Engine 的软件替换了 <code>Hypervisor</code>。这也是为什么，很多人会把 Docker 项目称为“轻量级”虚拟化技术的原因，实际上就是把虚拟机的概念套在了容器上。</p>
<p><strong>可是这样的说法并不严谨。容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。</strong></p>
<p>对于 Docker 等大多数 Linux 容器来说，<code>Cgroups</code> 技术是用来制造约束的主要手段，而 <code>Namespace</code>技术则是用来修改进程视图的主要方法。</p>
<p>假如运行一个容器，并进入其交互界面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> docker run -it busybox /bin/sh</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>

<p>再执行<code>ps</code>指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/ # ps</span><br><span class="line">PID  USER   TIME COMMAND</span><br><span class="line">  1 root   0:00 /bin/sh</span><br><span class="line">  10 root   0:00 ps</span><br></pre></td></tr></table></figure>

<p>可以看见，容器中的<code>/bin/bash</code>的<code>pid</code>为1，以及命令本身包含的ps，这说明Docker已经被隔离在了一个完全隔离的世界中了。</p>
<p>而Docker采用的隔离机制其实就是Linux的<code>NameSpace</code>技术。而 Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int pid = clone(main_function, stack_size, SIGCHLD, NULL);</span><br></pre></td></tr></table></figure>

<p>这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 <code>CLONE_NEWPID</code> 参数，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure>

<p>这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p>
<p>除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</p>
<p>比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。</p>
<p>这，就是 Linux 容器最基本的实现原理了。</p>
<p>由此可见，虚拟机和Docker的比对图应该如下所示</p>
<p><img src="/images/docker_VS_%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%AE%E6%AD%A3%E7%89%88.jpg" alt="docker VS 虚拟机修正版"></p>
<p>使用虚拟化技术作为应用沙盒，就必须要由 <code>Hypervisor</code> 来负责创建虚拟机，这个虚拟机是真实存在的，并且它里面必须运行一个完整的 Guest OS 才能执行用户的应用进程。这就不可避免地带来了额外的资源消耗和占用。相比之下，容器技术的应用并不需要单独的GuestOS，共享宿主机的内核。</p>
<p>但是，有利也有弊，Linux NameSpace在隔离上也存在<strong>隔离不彻底</strong>的问题。</p>
<p><strong>首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。</strong></p>
<p>这意味着，如果你要在 Windows 宿主机上运行 Linux 容器，或者在低版本的 Linux 宿主机上运行高版本的 Linux 容器，都是行不通的。</p>
<p><strong>其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。</strong></p>
<p>这意味着，在容器中修改了时间，宿主机的时间也会被修改，这显然不符合期望的要求。</p>
<p><strong>所以总结来说，容器，就是一种特殊的进程。</strong></p>
<h3 id="Cgroups限制"><a href="#Cgroups限制" class="headerlink" title="Cgroups限制"></a>Cgroups限制</h3><p>由于容器是一个特殊的进程，这意味着，它所能够使用到的资源（比如 CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的。当然，这个 100 号进程自己也可能把所有资源吃光。这些情况，显然都不是一个“沙盒”应该表现出来的合理行为。</p>
<p>好在<strong>Linux Cgroups就是Linux内核中用来设置资源限制的一个重要功能。</strong></p>
<p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 <code>/sys/fs/cgroup</code> 路径下。可以通过mount指令显示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> mount -t cgroup </span><br><span class="line">cpuset on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cpu on /sys/fs/cgroup/cpu type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">cpuacct on /sys/fs/cgroup/cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)</span><br><span class="line">blkio on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">memory on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，目录下有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> ls /sys/fs/cgroup/cpu</span><br><span class="line">cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release</span><br><span class="line">cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks</span><br></pre></td></tr></table></figure>

<p>其中cfs_period 和 cfs_quota 这两个参数需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间，tasks可以用来指定进程的PID。</p>
<p>对于配置文件的使用，需要到对应的子系统下创建一个目录，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu$ mkdir container</span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu$ ls container/</span><br><span class="line">cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release</span><br><span class="line">cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks</span><br></pre></td></tr></table></figure>

<p>这个目录被称为<code>控制组</code>，操作系统会在你新创建的 container 目录下，自动生成该子系统对应的资源限制文件。</p>
<p>假如在后台执行一个死循环脚本，让脚本将操作系统CPU吃满</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> while : ; do : ; done &amp;</span><br><span class="line">[1] 226</span><br></pre></td></tr></table></figure>

<p>可以通过top指令来确认CPU实时变化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> top</span><br><span class="line"><span class="meta">%</span>Cpu0 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br></pre></td></tr></table></figure>

<p>而此时，可以通过查看container目录下的文件，可以看到container 控制组里的 CPU quota 还没有任何限制（即：-1），CPU period 则是默认的 100  ms（100000  us）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us </span><br><span class="line">-1</span><br><span class="line"><span class="meta">$</span> cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us </span><br><span class="line">100000</span><br></pre></td></tr></table></figure>

<p>接下来可以通过修改配置文件的方式来对CPU占用率进行限制</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> echo 20000 &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> echo 226 &gt; /sys/fs/cgroup/cpu/container/tasks </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> top</span><br><span class="line"><span class="meta">%</span>Cpu0 : 20.3 us, 0.0 sy, 0.0 ni, 79.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br></pre></td></tr></table></figure>

<p>可以看到，CPU占用率立马降为20%。除 CPU 子系统外，Cgroups 的每一项子系统都有其独有的资源限制能力，比如：</p>
<ul>
<li>blkio：为块设备设定I/O 限制，一般用于磁盘等设备；</li>
<li>cpuset：为进程分配单独的 CPU 核和对应的内存节点；</li>
<li>memory：为进程设定内存使用的限制。</li>
</ul>
<p><strong>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。</strong>当然，至于控制组下面的资源文件限制值，可以在运行image的时候通过参数来指定</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us </span><br><span class="line">100000</span><br><span class="line"><span class="meta">$</span> cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us </span><br><span class="line">20000</span><br></pre></td></tr></table></figure>

<p>总结来说，容器是一个<code>单进程</code>模型，这意味着，一个容器没法运行两个不同的应用，因为没法找到一个公共的PID=1来充当两个不同应用的父进程。这是因为容器本身的设计就是希望应用和容器同生命周期。</p>
<p>同样，Cgroups也是有利有弊，最明显的就是<code>/proc</code>文件系统问题。</p>
<p><code>/proc</code>是用来存放当前内核的运行状态的一些特殊文件集合，比如CPU使用情况，内存使用情况，top指令的主要来源值就是来自于这里。但是，在容器中，<code>proc</code>显示的是宿主机的数据，这是绝对不允许的。</p>
<p>当然，可采用<code>lxcfs</code>来隔离宿主机和容器的文件系统。</p>
<h3 id="容器文件系统的深入理解"><a href="#容器文件系统的深入理解" class="headerlink" title="容器文件系统的深入理解"></a>容器文件系统的深入理解</h3><p>由于NameSpace的作用是<code>隔离</code>，它的应用让容器只能看到该NameSpace内的世界；Cgroups的作用是<code>限制</code>，，它的作用是限制容器对于资源的使用率。对于理想的容器文件系统应该是看到一份完全独立的文件系统，且不受宿主机的影响。关于Mount NameSpace的小实验可以参考<a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">DOCKER基础技术</a>,可以得出结论是：</p>
<p><strong>Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</strong></p>
<p>对于刚进入容器的文件系统来说，容器使用的是Linux名为<code>chroot</code>的指令，即改变进程根目录到指定的目录下。用法如下所示：</p>
<p>首先，创建一个test目录和几个lib文件夹，再把bash命令拷贝到test目录下对应的bin目录下，接下来，把 bash 命令需要的所有 so 文件，也拷贝到 test 目录对应的 lib 路径下。找到 so 文件可以用 ldd 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir -p $HOME/test</span><br><span class="line"><span class="meta">$</span> mkdir -p $HOME/test/&#123;bin,lib64,lib&#125;</span><br><span class="line"><span class="meta">$</span> cd $T</span><br><span class="line"><span class="meta">$</span> cp -v /bin/&#123;bash,ls&#125; $HOME/test/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> T=$HOME/test</span><br><span class="line"><span class="meta">$</span> list="$(ldd /bin/ls | egrep -o '/lib.*\.[0-9]')"</span><br><span class="line"><span class="meta">$</span> for i in $list; do cp -v "$i" "$&#123;T&#125;$&#123;i&#125;"; done</span><br></pre></td></tr></table></figure>

<p>最后，执行 chroot 命令，告诉操作系统，我们将使用 $HOME/test 目录作为 /bin/bash 进程的根目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> chroot $HOME/test /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>这时，你如果执行 “ls /“，就会看到，它返回的都是 $HOME/test 目录下面的内容，而不是宿主机的内容。实际上，Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。</strong></p>
<p>当然，为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Ubuntu16.04 的 ISO。</p>
<p>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：<code>rootfs</code>（根文件系统）。</p>
<p>现在，对于Docker项目来说，最核心的原理已经完成了，即：</p>
<ul>
<li>启用 Linux Namespace 配置；</li>
<li>设置指定的 Cgroups 参数；</li>
<li>切换进程的根目录（Change Root）。</li>
</ul>
<p>不过需要注意的是，<strong>rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</strong></p>
<p>也就是说，同一台机器上的所有容器，都共享一个操作系统内核，这也是容器相比于虚拟机的主要区别：毕竟后者有模拟出来的硬件机器充当沙盒，每个沙盒中还有一个完整的GuestOS。</p>
<p>当然，在有了rootfs之后，还必须面对的一个问题就是，是否需要每次改动一下应用都需要重新制作一次rootfs。</p>
<p>Docker的做法是，在镜像的设计中，引入了<code>层（layer）</code>的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p>
<p>这个做法主要依赖Linux的联合文件系统(Union File System)，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。比如，我现在有两个目录 A 和 B，它们分别有两个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│  ├── a</span><br><span class="line">│  └── x</span><br><span class="line">└── B</span><br><span class="line">  ├── b</span><br><span class="line">  └── x</span><br></pre></td></tr></table></figure>

<p>然后，我使用联合挂载的方式，将这两个目录挂载到一个公共的目录 C 上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir C</span><br><span class="line"><span class="meta">$</span> mount -t aufs -o dirs=./A:./B none ./C</span><br></pre></td></tr></table></figure>

<p>这时，我再查看目录 C 的内容，就能看到目录 A 和 B 下的文件被合并到了一起：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tree ./C</span><br><span class="line">./C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br></pre></td></tr></table></figure>

<p>Docker采用<code>AuFS</code>这个联合文件系统来实现联合挂载，对于 AuFS 来说，它最关键的目录结构在 /var/lib/docker 路径下的 diff 目录：<code>/var/lib/docker/aufs/diff/&lt;layer_id&gt;</code>，而在使用镜像时，Docker 会把这些增量联合挂载在一个统一的挂载点上<code>/var/lib/docker/aufs/mnt/&lt;layer_id&gt;</code>。</p>
<p>而且，从这个结构可以看出来，这个容器的 rootfs 由如下图所示的三部分组成：</p>
<p><img src="/images/docker%E5%88%86%E5%B1%82.png" alt="docker分层"></p>
<p><strong>第一部分：只读层</strong></p>
<p>它是这个容器的 rootfs 最下面的五层，对应的正是 ubuntu:latest 镜像的五层。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls /var/lib/docker/aufs/diff/72b0744e06247c7d0...</span><br><span class="line">etc sbin usr var</span><br><span class="line"><span class="meta">$</span> ls /var/lib/docker/aufs/diff/32e8e20064858c0f2...</span><br><span class="line">run</span><br><span class="line"><span class="meta">$</span> ls /var/lib/docker/aufs/diff/a524a729adadedb900...</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>

<p>可以看到，这些层，都以增量的方式分别包含了 Ubuntu 操作系统的一部分。</p>
<p><strong>第二部分：可读写层</strong></p>
<p>在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。</p>
<p>而对于删除来说，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。</p>
<p><strong>第三部分：Init层</strong></p>
<p>它是一个以<code>-init</code>结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。</p>
<p>需要这样一层的原因是，这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。</p>
<p>所以，Docker 做法是，在修改了这些文件之后，以一个单独的层挂载了出来。而用户执行 docker commit 只会提交可读写层，所以是不包含这些内容的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17010.html</a></li>
<li><a href="https://time.geekbang.org/column/intro/116" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/116</a></li>
</ol>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/08/16/引用计数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/16/引用计数/" class="post-title-link" itemprop="url">Python的垃圾回收机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-16 18:35:30 / 修改时间：18:35:57" itemprop="dateCreated datePublished" datetime="2019-08-16T18:35:30+08:00">2019-08-16</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数是指当对象的引用计数(指针数)为0时，表示这个对象不可达，需要被回收</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前 python 程序占用的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory_info</span><span class="params">(hint)</span>:</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    </span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; memory used: &#123;&#125; MB'</span>.format(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">'after a created'</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">show_memory_info(<span class="string">'finished'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"></span><br><span class="line">initial memory used: <span class="number">47.19140625</span> MB</span><br><span class="line">after a created memory used: <span class="number">433.91015625</span> MB</span><br><span class="line">finished memory used: <span class="number">48.109375</span> MB</span><br></pre></td></tr></table></figure>

<p>这个例子说明的是，a是局部变量，当包含a的函数执行完成之后，a的引用就变为0，也就被回收了，想要改变这种方式的话，只需要将a设置为<code>global</code>变量即可</p>
<p>这里存在的问题是，如果a是被返回的值，那么列表a的生命周期就没有消失，仍然会继续占用内存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">'after a created'</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>查看对象的引用次数可用sys模块中的<code>getrefcount</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">print(sys.getrefcount(a))	<span class="comment">#output:2(一次来自于a，一次来自于getrefcount自身)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_count</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(sys.getrefcount(a))</span><br><span class="line"><span class="comment">#output:4(a,python函数调用，函数参数，getrefcount)</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数调用时，函数本身和函数参数都会产生调用，<code>sys.getrefcount()</code>并不是统计的指针数，而是统计指针指向的变量数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.getrefcount(a))</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.getrefcount(a))</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.getrefcount(a))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>而回收内存的方法也很简单，先调用del语句，在强制调用<code>gc.collect()</code>手动启动垃圾回收即可</p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>python中绝大部分都采用的<code>引用计数</code>的垃圾回收机制，但是，当多个计数存在相互调用的情况下时，可能为内存带来很大的负担</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">'after a, b created'</span>)</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">show_memory_info(<span class="string">'finished'</span>)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">initial memory used: 8.2421875 MB</span></span><br><span class="line"><span class="string">after a, b created memory used: 783.05078125 MB</span></span><br><span class="line"><span class="string">finished memory used: 783.05078125 MB</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>由上例可以看出，当<code>func</code>函数执行完之后，按理说a, b的生命周期已经结束，但是可以看出内存并没有释放。因为他们还有相互引用，导致内存并没有释放。</p>
<p>如果想要回收内存，可以显示调用<code>gc.collect()</code>手动启动垃圾回收</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func()</span><br><span class="line">gc.collect()</span><br><span class="line">show_memory_info(<span class="string">'finished'</span>)</span><br></pre></td></tr></table></figure>

<p>python采用<code>标记清除算法</code>和<code>分代收集</code>，来启用针对循环引用的自动垃圾回收。</p>
<p>标记清除大致的意思是，python会想一个有向图一样去遍历每个节点，如果存在没有被标记的节点就会被回收，当然，不可能每次都去遍历全部节点，python采用的是双向链表维护了一个数据结构。</p>
<p>分代收集是指，python将所有对象分为三代。刚刚创建的对象为第0代，经过一次垃圾回收之后，依然存在的对象便会从上一代挪到下一代。而每一代都会有自动垃圾回收的阈值，值是可以单独指定的，当垃圾回收时，到达阈值时，对象就会被回收。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/08/09/深入理解迭代器和生成器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/09/深入理解迭代器和生成器/" class="post-title-link" itemprop="url">深入理解迭代器和生成器</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-09 18:25:01 / 修改时间：18:26:43" itemprop="dateCreated datePublished" datetime="2019-08-09T18:25:01+08:00">2019-08-09</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于生成器来说，最大的作用可能是对于内存的节省，因为每次调用<code>next()</code>函数才会去取一次数据，直到抛出<code>StopIteration</code>异常。但这并不是本次笔记的重点，本次笔记的重点在于一定要牢记每次调用生成器之后，都会消耗生成器中的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>对于经常使用的<code>(i in a)</code>来说，其实它底层调用的还是生成器原理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    val = next(a)</span><br><span class="line">    <span class="keyword">if</span> val == i:</span><br><span class="line">        <span class="keyword">yield</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>所以，先看以下示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="number">2</span> <span class="keyword">in</span> b)</span><br><span class="line">print(<span class="number">4</span> <span class="keyword">in</span> b)</span><br><span class="line">print(<span class="number">3</span> <span class="keyword">in</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>原因在于每次使用print函数时，都会消耗掉b中的值，而每次使用in函数时，比如<code>2 in b</code>就会消耗掉0, 1, 2这三个值，剩下3, 4这两个值，而<code>4 in b</code>时，其中存在4，就返回为True，此时b中已消耗完所有元素，在此调用就会失败。</p>
<p>在看一个<a href="https://leetcode-cn.com/problems/is-subsequence/submissions/" target="_blank" rel="noopener">leetcode示例</a>，给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_subsequence</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    b = iter(b)</span><br><span class="line">    <span class="keyword">return</span> all(i <span class="keyword">in</span> b <span class="keyword">for</span> i <span class="keyword">in</span> a)</span><br><span class="line"></span><br><span class="line">print(is_subsequence([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line">print(is_subsequence([<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/08/09/python参数传递/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/09/python参数传递/" class="post-title-link" itemprop="url">Python的参数传递机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-09 18:25:01 / 修改时间：18:28:56" itemprop="dateCreated datePublished" datetime="2019-08-09T18:25:01+08:00">2019-08-09</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先看以下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量的赋值，表示让变量指向某个对象，并不是拷贝对象给变量；而一个对象是可以由多个对象指向</li>
<li>可变对象(列表，字典，集合等)的改变，会影响所有指向该对象的变量</li>
<li>对于不可变对象(字符串，整型，元祖)的改变，所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作(+,=等等)更新不可变对象时，会返回一个新的对象</li>
<li>变量可以被删除，但对象无法被删除。这也和python的垃圾回收机制相符合，只有当该对象的指向变量为0个时，才会回收该对象。</li>
</ul>
<p>通过以下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>由于1是不可变对象，a, b都是指向1这个变量，a的值变化时，相当于a的指向又会重新改变，而b的指向是没有变化的</p>
<p><img src="/images/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" alt="1565256260196"></p>
<p>而对于可变对象来说，a, b会同时指向一个内存地址，改变可变对象的值，会改变所有指向该对象的变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" alt="1565312225472"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，变量a和b同时指向1这个对象，当执行到a = 2时，是将a重新指向了2这个对象，而b仍然还是指向的1这个对象</p>
<p>如果想要改变上述过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = func(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可将b变量重新指向2这个对象，这样就能改变b的值</p>
<p>而对于可变参数来说，改变对象的值，会改变所有指向它的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    a += [<span class="number">4</span>]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = a + [<span class="number">4</span>]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>需要注意的是，a += [4]和a = a + [4]是不相同的操作，a = a + [4]是表示新创建一个新的列表，然后让a重新指向它，而a += [4]是一个自增的过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">2610677016776</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += [<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">2610677016776</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a + [<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">2610680008648</span></span><br></pre></td></tr></table></figure>

<p>总结来说：</p>
<ul>
<li>如果对象是可变的，对象改变时，指向这个对象的所有变量都会改变</li>
<li>如果对象是不可变的，对象改变时，指向这个对象的变量不会受到影响</li>
<li>为了安全，函数末尾尽量使用return返回</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/08/09/装饰器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/09/装饰器/" class="post-title-link" itemprop="url">装饰器</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-09 18:25:01 / 修改时间：18:26:05" itemprop="dateCreated datePublished" datetime="2019-08-09T18:25:01+08:00">2019-08-09</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前对于装饰器的理解感觉比较片面，没成体系，在此记录一下装饰器的学习之路</p>
<blockquote>
<p>Decorators is to modify the behavior of the function through a wrapper so we don’t have to actually modify the function.</p>
</blockquote>
<p>也就是说，<strong>所谓装饰器，就是通过装饰器函数，来修改原函数的一些功能，使原函数在不需要修改的情况下达到某些目的。</strong>通常广泛应用于日志，身份认证，缓存等方面。</p>
<h4 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h4><p>先看一个简单例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'wrapper of decorator'</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line">greet()</span><br></pre></td></tr></table></figure>

<p><code>@</code>被称为语法糖，@my_decorator就相当于my_decorator(greet)，当然，my_decorator和greet函数也能带参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'wrapper of decorator'</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>这样也不是万无一失的，我们发现greet函数的元信息发生了变化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greet.__name__</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="string">'wrapper'</span></span><br><span class="line"></span><br><span class="line">help(greet)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Help on function wrapper <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">wrapper(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，通常使用内置装饰器<code>@functools.wrap</code>，它会帮助我们保留函数的元信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'wrapper of decorator'</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line">greet.__name__</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="string">'greet'</span></span><br></pre></td></tr></table></figure>

<h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p>不仅不可以使用函数装饰器，类也可以使用装饰器。类装饰器主要依赖于<code>__call__</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.num_calls = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.num_calls += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'num of calls is: &#123;&#125;'</span>.format(self.num_calls))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Count</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">example()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">num of calls <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">example()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">num of calls <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>装饰器也可以是嵌套使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="meta">@decorator3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decorator1(decorator2(decorator3(func)))</span><br></pre></td></tr></table></figure>

<h4 id="实际用法"><a href="#实际用法" class="headerlink" title="实际用法"></a>实际用法</h4><p>最常用的应该还是日志记录。如果想要测试某些函数的耗时时长，装饰器就是一种常用方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_execution_time</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        print(<span class="string">'&#123;&#125; took &#123;&#125; ms'</span>.format(func.__name__, (end - start) * <span class="number">1000</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@log_execution_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_similarity</span><span class="params">(items)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>对于身份认证来说，往往使用需要登录之后才能使用的功能，例如评论，在校验这种身份的时候也经常使用装饰器来校验</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        request = args[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> check_user_logged_in(request): <span class="comment"># 如果用户处于登录状态</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs) <span class="comment"># 执行函数 post_comment() </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Authentication failed'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@authenticate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_comment</span><span class="params">(request, ...)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br></pre></td></tr></table></figure>

<p>另外，对于测试来说，往往需要传入某种格式固定的参数，例如传入值的先后顺序时候合法等，也常用装饰器来进行校验</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_check</span><span class="params">(input)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line">        ... <span class="comment"># 检查输入是否合法</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@validation_check</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neural_network_training</span><span class="params">(param1, param2, ...)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/08/07/python比较与拷贝问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/07/python比较与拷贝问题/" class="post-title-link" itemprop="url">Python比较符与拷贝问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-07 19:13:12 / 修改时间：19:14:31" itemprop="dateCreated datePublished" datetime="2019-08-07T19:13:12+08:00">2019-08-07</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="is-VS"><a href="#is-VS" class="headerlink" title="is VS =="></a>is VS ==</h3><p>简单来说，<code>==</code>比较的是值大小，<code>is</code>比较的是内存地址，总的来说，is运算符的速度大于==运算符，这是在于is运算符没办法重载，而运行==运算符时，程序会先去搜索<code>__eq__</code>函数，如果没有重载，就会直接比较大小，由于python很多内置的函数都重载了<code>__eq__</code>函数</p>
<p>值得注意的是，对于整型数字来说，a is b为True的结论，只适用于-5到256之间，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">2314450519952</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">2314450941424</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>原因在于，出于性能考虑，python内部会维持一个-5到256的数组，起到一个缓存的作用。每次你去创建一个-5到256范围的整型数字时，python会去这个数组中取值，而不是去创建一个新的内存。</p>
<h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p><strong>浅拷贝</strong>：是指重新分配一块内存，创建一个新的对象，里面的元素是对原对象中子对象的引用。如果原对象中元素是不可变类型，不会产生影响，如果是可变类型，会带来新对象的改变。</p>
<p><strong>深拷贝</strong>：指重新分配一块新的内存地址，创建一个新的对象和新的元素，和原对象没有任何关联。</p>
<p>注意，浅拷贝带来的变化只针对原对象的子对象是可变类型数据，例如嵌套列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] += (<span class="number">5</span>, )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] += (<span class="number">5</span>, )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<p>而深拷贝不会受到任何影响</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<p>深拷贝也不是完美的，如果被拷贝对象是自身，程序有可能会陷入无限循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.append(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, [...]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = deepcopy(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="number">1</span>, [...]]</span><br></pre></td></tr></table></figure>

<p>x为一个无限嵌套的列表，深拷贝的时候，程序并没有报<code>stack overflow</code>的现象，这是在于深拷贝函数内部维护这一个字典，记录已经拷贝对象和ID，拷贝过程中，如果字典里存储了将要拷贝对象，会直接将字典中内容返回</p>
<p>而在使用==比较深拷贝之后的无限嵌套列表时，会抛出异常<code>RecursionError: maximum recursion depth exceeded in comparison</code>，这是在于列表中==会去遍历每个值的大小再去比较，而列表时无限嵌套的，所以会抛出异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x = [<span class="number">1</span>]</span><br><span class="line">x.append(x)</span><br><span class="line">y = copy.deepcopy(x)</span><br><span class="line">print(x == y)	<span class="comment">#RecursionError: maximum recursion depth exceeded in comparison</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/08/07/SQL进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/07/SQL进阶/" class="post-title-link" itemprop="url">sql范式</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-07 19:13:12 / 修改时间：19:14:31" itemprop="dateCreated datePublished" datetime="2019-08-07T19:13:12+08:00">2019-08-07</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sql/" itemprop="url" rel="index"><span itemprop="name">sql</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>我们在设计数据库模型的时候，需要对关系内部各个属性之间联系的合理化程度进行定义，这就有了不同等级的规范要求，这些规范要求就被称为范式(NF)。也可以理解为，一张数据表的设计结构需要满足的某种设计标准级别。</p>
<p>目前关系型数据库一共有6种范式，，由低到高分别为：</p>
<ol>
<li>1NF（第一范式）</li>
<li>2NF（第二范式）</li>
<li>3NF（第三范式）</li>
<li>BCNF（巴斯-科德范式）</li>
<li>4NF（第四范式）</li>
<li>5NF（第五范式，也叫完美范式）</li>
</ol>
<p>数据库范式的设计越高阶，冗余度就越低，同时高阶的范式一定会满足低阶的要求。</p>
<p><strong>数据库表中键的定义</strong>：</p>
<ul>
<li><p>超键：能唯一标识的属性集</p>
</li>
<li><p>候选键：如果超键中不包含多余的属性，那么这个键就是超键</p>
</li>
<li><p>主键：用户可以从候选键中选择一个键作为主键</p>
</li>
<li><p>外键：如果R1数据表中某属性集不是R1的主键，而是另一个表R2的主键，那么这个键就是R1的主键</p>
</li>
<li><p>主属性：包含任一候选键的属性成为主属性</p>
</li>
<li><p>非主属性：与主属性相对，不包含任何一个候选键的属性</p>
</li>
</ul>
<p><strong>第一范式</strong>：<strong>指的是数据表中任何属性都是原子性的，不可再分</strong>。几乎所有关系型数据库都满足第一范式的要求。</p>
<p><strong>第二范式</strong>：<strong>指的是数据表的非主属性都要和这个数据表的候选键有完全依赖</strong>。以球员表player_game表为例，包含球员编号，姓名，年龄，比赛编号，比赛时间和比赛场地等属性，这里的候选键和主键分别为(球员编号和比赛编号)。但是这个数据表设计并不满足第二范式，因为还存在以下对应关系:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(球员编号)--&gt; (姓名，年龄)</span><br><span class="line">(比赛编号) --&gt; (比赛时间，比赛场地)</span><br></pre></td></tr></table></figure>

<p>这样会产生以下问题：</p>
<ol>
<li>数据冗余：如果一个球员可以参加n场比赛，那么球员的姓名和年龄就重复了n-1次。一个比赛可能有m个球员参加，比赛时间和场地就重复了m-1次</li>
<li>插入异常：我们想要添加一场新的比赛，但是这时还没确定参加的球员都有谁，那么久没法插入</li>
<li>删除异常：比如想要删除某个球员编号，如果没有单独保存比赛表时，就会把比赛信息也删除掉</li>
<li>更新异常：如果想要调整某个比赛时间，那么数据表中所有时间都要调整</li>
</ol>
<p>为避免以上情况，可以将一张表拆分为3张表。球员player表包含球员编号，年龄，姓名；比赛game表包含比赛编号，比赛时间和比赛场地等属性；球员关系player_game表包含球员编号，比赛编号，比赛得分等属性</p>
<p><strong>第三范式：对任何非主属性都不传递依赖于候选键。</strong></p>
<p>以球员player表为例，这张表包含球员编号，姓名，球队名称，球队主教练。球员编号决定了球队名称，球队名称决定了球队主教练，那么非主属性球队主教练就依赖于候选键球员编号。需要将player表拆分为下面这样：</p>
<p>球员表包含球员编号，姓名和球队名称；球队表包含球队名称和球队主教练。</p>
<p>当然，也不一定是范式越高就越好，越高阶以为这冗余越少，同时数据表也越多，搜索的时间也越大。实际工作中往往根据实际情况适当采用<strong>反范式</strong>，以时间换取空间的做法，容忍适当的冗余。</p>
<table>
<thead>
<tr>
<th>仓库名</th>
<th>管理员</th>
<th>物品名</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>北京仓</td>
<td>张三</td>
<td>iPhone XR</td>
<td>10</td>
</tr>
<tr>
<td>北京仓</td>
<td>张三</td>
<td>iPhone 7</td>
<td>20</td>
</tr>
<tr>
<td>上海仓</td>
<td>李四</td>
<td>iPhone 8</td>
<td>30</td>
</tr>
<tr>
<td>上海仓</td>
<td>李四</td>
<td>iPhone X</td>
<td>40</td>
</tr>
</tbody></table>
<p>在上表中，一个仓库只有一个管理员，同时一个管理员也管理者一个仓库。这样候选键为(仓库名，物品名)和(管理员，物品名)，然后我们从中选取一个候选键作为主键。按照以上理论梳理，此表满足了1NF,2NF,3NF规范，但是同样存在以下问题：</p>
<ol>
<li>增加一个仓库，但是没有存放任何物品，根据数据完整性的要求，主键不能有空值，因此会出现插入异常</li>
<li>仓库管理员更换之后，会修改多条记录</li>
<li>仓库物品卖空后，仓库名称和管理员都会随之删除掉</li>
</ol>
<p>由此引入<strong>BCNF</strong>(巴斯-科德范式)：<strong>它在3NF的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong></p>
<p>按照<code>BCNF</code>要求，我们需要将上表拆分为两个表：</p>
<ul>
<li>仓库表：(仓库名，管理员)</li>
<li>库存表：（仓库名，物品名，数量）</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/bigmorebig/bigmorebig.github.io/2019/08/05/SQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐潇唐">
      <meta itemprop="description" content="进击的测试">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/05/SQL/" class="post-title-link" itemprop="url">sql基础</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-05 18:36:36" itemprop="dateCreated datePublished" datetime="2019-08-05T18:36:36+08:00">2019-08-05</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-08 20:24:36" itemprop="dateModified" datetime="2019-08-08T20:24:36+08:00">2019-08-08</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sql/" itemprop="url" rel="index"><span itemprop="name">sql</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Oracle执行流程"><a href="#Oracle执行流程" class="headerlink" title="Oracle执行流程"></a>Oracle执行流程</h3><p><img src="/images/Oracle%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="oracle执行流程"></p>
<ol>
<li><p><strong>语法检查</strong>：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</p>
</li>
<li><p><strong>语义检查</strong>：检查 SQL 中的访问对象是否存在。比如我们在写SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</p>
</li>
<li><p><strong>权限检查</strong>：看用户是否具备访问该数据的权限。</p>
</li>
<li><p><strong>共享池检查</strong>：共享池(Shared Pool)是一块内存池，最主要的作用是缓存SQL语句和该语句的执行计划。Oracle通过检查共享池是否存在SQL语句的执行计划，来判断进行软解析</p>
<ul>
<li>软解析：在共享池中，Oracle首先对SQL语句进行Hash运算，然后根据Hash值在库缓存(Library Cache)中查找，如果存在SQL语句的执行计划，就直接拿来用，直接进入’执行器’环节</li>
<li>硬解析：如果没找到SQL语句和执行计划，Oracle就需要创建解析树进行解析，生成执行计划，进入’优化器’这个环节</li>
</ul>
</li>
<li><p>优化器：优化器中就需要进行硬解析，也就是决定怎么做，比如创建执行树，生成执行计划</p>
</li>
<li><p>执行器：执行SQL语句</p>
</li>
</ol>
<h3 id="MYSQL架构"><a href="#MYSQL架构" class="headerlink" title="MYSQL架构"></a>MYSQL架构</h3><p><img src="/images/MYSQL%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="MYSQL架构"></p>
<p>MYSQL是典型的的C/S架构，服务端程序应用的是mysqld</p>
<ol>
<li><strong>连接层</strong>：客户端和服务器建立连接，客户端发送SQL至服务端</li>
<li><strong>SQL层</strong>：对SQL语句进行查询处理</li>
<li><strong>存储引擎层</strong>：与数据文件打交道，负责数据存储和读取</li>
</ol>
<h3 id="MYSQL执行流程"><a href="#MYSQL执行流程" class="headerlink" title="MYSQL执行流程"></a>MYSQL执行流程</h3><p><img src="/images/MYSQL%E7%BB%93%E6%9E%84.jpg" alt="mysql执行流程"></p>
<ol>
<li><strong>缓存查询</strong>：Server在缓存中查询到了这条语句，会直接将结果返回给客户端，如果没有，就会进入解析器阶段。需要说明的是，因为查询效率不高，所以在MySQL8.0之后就抛弃掉这个功能</li>
<li><strong>解析器</strong>：在解析器中对SQL语句进行语法分析，语句分析</li>
<li><strong>优化器</strong>：在优化器中会确定SQL语句的执行路径</li>
<li><strong>执行器</strong>：在执行之前需要判断用户是否具备权限，如果具备权限就执行SQL查询并返回结果。在MySQL8.0以下版本，会将查询结果缓存。</li>
</ol>
<h3 id="SELECT执行顺序"><a href="#SELECT执行顺序" class="headerlink" title="SELECT执行顺序"></a>SELECT执行顺序</h3><ol>
<li><p>查询的关键字顺序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>SELECT的执行顺序(在MYSQL和Oracle中SELECT的执行顺序基本相同)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &gt; WHERE &gt; GROUP BY &gt; HAVING &gt; SELECT 的字段 &gt; DISTINCT &gt; ORDER BY &gt; LIMIT</span><br></pre></td></tr></table></figure>

<p>详细顺序如下所示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">num</span> <span class="comment"># 顺序 5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id = team.team_id <span class="comment"># 顺序 1</span></span><br><span class="line"><span class="keyword">WHERE</span> height &gt; <span class="number">1.80</span> <span class="comment"># 顺序 2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id <span class="comment"># 顺序 3</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt; <span class="number">2</span> <span class="comment"># 顺序 4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span> <span class="comment"># 顺序 6</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span> <span class="comment"># 顺序 7</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="SQL内置函数"><a href="#SQL内置函数" class="headerlink" title="SQL内置函数"></a>SQL内置函数</h3><p>通常将内置函数分为四类：</p>
<ol>
<li>算术函数</li>
<li>字符串函数</li>
<li>日期函数</li>
<li>转换函数</li>
</ol>
<h4 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>ABS()</td>
<td>去绝对值</td>
</tr>
<tr>
<td>MOD()</td>
<td>取余</td>
</tr>
<tr>
<td>ROUND()</td>
<td>四舍五入为指定小数位数，需要有两个参数，分别为字段名称和小数位数</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ABS</span>(<span class="number">-2</span>);		<span class="comment">#output:2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MOD</span>(<span class="number">10</span>, <span class="number">3</span>);	<span class="comment">#output:1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">1.123456</span>, <span class="number">2</span>)	<span class="comment">#output:1.12</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT()</td>
<td>将多个字段拼接起来</td>
</tr>
<tr>
<td>LENGTH()</td>
<td>计算字段长度，一个汉字算3个字符</td>
</tr>
<tr>
<td>CHAR_LENGTH()</td>
<td>计算字段长度，汉字，字母，数字都算1个字符</td>
</tr>
<tr>
<td>LOWER()</td>
<td>将字符串转换为小写</td>
</tr>
<tr>
<td>UPPER()</td>
<td>将字符串转换为大写</td>
</tr>
<tr>
<td>REPLACE()</td>
<td>替换函数，有3个参数，分别为：要替换的表达式或字段名，old,new</td>
</tr>
<tr>
<td>SUBSTRING()</td>
<td>截取字符串，有3个参数，分别为：字符串，开始位置，截取长度（下边从1开始）</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SELECT CONCAT('aa','bb','cc') as concat;</span></span><br><span class="line"><span class="comment">-- SELECT LENGTH('qwerty') as len;</span></span><br><span class="line"><span class="comment">-- SELECT LENGTH('唐肖') as han_len;</span></span><br><span class="line"><span class="comment">-- SELECT CHAR_LENGTH('唐肖') as char_len;</span></span><br><span class="line"><span class="comment">-- SELECT LOWER('PYTHON') as low;</span></span><br><span class="line"><span class="comment">-- SELECT UPPER('python') as up;</span></span><br><span class="line"><span class="comment">-- SELECT REPLACE('weekday', 'k','ken') as re;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTRING</span>(<span class="string">'python'</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="keyword">as</span> sub;</span><br></pre></td></tr></table></figure>

<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>CURRENT_DATE()</td>
<td>系统当前日期</td>
</tr>
<tr>
<td>CURRENT_TIME()</td>
<td>系统当前时间，没有具体日期</td>
</tr>
<tr>
<td>CURRENT_TIMESTAMP()</td>
<td>系统当前时间，包含日期和时间</td>
</tr>
<tr>
<td>EXTRACT()</td>
<td>抽取具体的年，月，日</td>
</tr>
<tr>
<td><strong>DATE()</strong></td>
<td>返回时间的日期部分</td>
</tr>
<tr>
<td>YEAR()</td>
<td>返回时间的年</td>
</tr>
<tr>
<td>MONTH()</td>
<td>返回时间的月</td>
</tr>
<tr>
<td>DAY()</td>
<td>返回时间的天数</td>
</tr>
<tr>
<td>HOUR()</td>
<td>返回时间的小时</td>
</tr>
<tr>
<td>MINUTE()</td>
<td>返回时间的分钟</td>
</tr>
<tr>
<td>SECOND()</td>
<td>返回时间的秒</td>
</tr>
</tbody></table>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>CAST()</td>
<td>数据类型转换，参数是一个表达式，表达式通过AS关键词分割了2个参数，分别是原始数据和目标类型数据</td>
</tr>
<tr>
<td>COALESCE()</td>
<td>返回第一个非空数值</td>
</tr>
</tbody></table>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EXISTS</td>
<td>判断条件是否存在，存在未True，否则为False</td>
</tr>
<tr>
<td>IN</td>
<td>判断是否在结果集中</td>
</tr>
<tr>
<td>ANY</td>
<td>需要与比较操作符一起使用，与子查询返回的任何值做比较</td>
</tr>
<tr>
<td>ALL</td>
<td>需要与比较操作符一起使用，与子查询返回的所有值做比较</td>
</tr>
</tbody></table>
<ol>
<li>查看出场过的球员都有哪些</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id, team_id, player_name <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> player_id <span class="keyword">FROM</span> player_score <span class="keyword">WHERE</span> player.player_id = player_score.player_id)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询球员表中，比印第安纳步行者（对应的 team_id 为1002）中任何一个球员身高高的球员的信息</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL: <span class="keyword">SELECT</span> player_id, player_name, height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> height &gt; <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> team_id = <span class="number">1002</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查询球员表中，比印第安纳步行者（对应的 team_id 为1002）中所有球员身高高的球员的信息</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL: <span class="keyword">SELECT</span> player_id, player_name, height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> height &gt; <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> team_id = <span class="number">1002</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查询场均得分大于 20 的球员。场均得分从player_score 表中获取</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,team_id,player_name <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player_id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> player_id <span class="keyword">FROM</span> player_score <span class="keyword">GROUP</span> <span class="keyword">BY</span> player_id <span class="keyword">HAVING</span> <span class="keyword">AVG</span>(score) &gt; <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><p>由于主流关系型数据库对SQL92的支持更好，在此以SQL92作为示例。</p>
<h4 id="交叉查询"><a href="#交叉查询" class="headerlink" title="交叉查询"></a>交叉查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> team</span><br></pre></td></tr></table></figure>

<p>通过<code>CROSS JOIN</code>关键字可以得到两张表的笛卡尔积查询结果，当然也可以多次使用该关键字来连接多张表</p>
<h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>使用<code>NATURAL JOIN</code>关键字可以自动连接两张表相同的关键字，然后进行等值连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id, team_id, player_name, height, team_name <span class="keyword">FROM</span> player <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> team</span><br></pre></td></tr></table></figure>

<h4 id="ON连接"><a href="#ON连接" class="headerlink" title="ON连接"></a>ON连接</h4><p><code>ON</code>用来指定连接条件，<code>ON player.team_id = team.team_id</code>相当于是指定team_id字段的等值连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id, player.team_id, player_name, height, team_name <span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id = team.team_id</span><br></pre></td></tr></table></figure>

<p>当然，也可以进行非等值连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.player_name, p.height, h.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">as</span> p <span class="keyword">JOIN</span> height_grades <span class="keyword">as</span> h</span><br><span class="line"><span class="keyword">ON</span> height <span class="keyword">BETWEEN</span> h.height_lowest <span class="keyword">AND</span> h.height_highest</span><br></pre></td></tr></table></figure>

<h4 id="USING"><a href="#USING" class="headerlink" title="USING"></a>USING</h4><p>使用<code>USING</code>关键字指定数据库中相同字段名进行等值连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id, team_id, player_name, height, team_name <span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">USING</span>(team_id)</span><br></pre></td></tr></table></figure>

<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>包含三种连接方式：</p>
<ol>
<li>左连接：LEFT JOIN</li>
<li>右连接：RIGHT JOIN</li>
<li>全连接：FULL JOIN</li>
</ol>
<p>值得注意的是，MYSQL并不支持全连接</p>
<p>例子：根据不同身高等级查询球员的个数，输出身高等级和个数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> height_level, <span class="keyword">count</span>(*) <span class="keyword">FROM</span> height_grades <span class="keyword">as</span> h <span class="keyword">JOIN</span> player <span class="keyword">as</span> p <span class="keyword">ON</span> p.height <span class="keyword">BETWEEN</span> h.height_lowest <span class="keyword">AND</span> h.height_highest <span class="keyword">GROUP</span> <span class="keyword">BY</span> height_level;</span><br></pre></td></tr></table></figure>

<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图作为一张虚拟表，只是帮助我们封装底层与数据库接口，相当于一张表或多张表的结果集，视图一般在数据量比较大的情况下使用，它具有以下特点，</p>
<ul>
<li>安全性：虚拟表是基于底层数据库的，我们在使用视图时一般不会通过视图对底层数据进行修改，在一定程度上保证了数据的安全性，同时，还可以针对不同用户开放不同的数据查询权限</li>
<li>简单清晰：视图是对SQL语句的封装，将原来复杂的语句简单化，类似于函数的作用</li>
</ul>
<p><strong>创建视图</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> avg_height <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(height) <span class="keyword">FROM</span> player;</span><br></pre></td></tr></table></figure>

<p>同时，视图还支持视图嵌套</p>
<p><strong>修改视图</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure>

<p><strong>删除视图</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name</span><br></pre></td></tr></table></figure>

<p><strong>关于视图的应用</strong></p>
<p>查询球员中的身高介于1.90m到2.08m之间的名字，身高，以及对应的身高等级</p>
<ol>
<li><p>创建身高等级的视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_height_grades <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> p.player_name, p.height, h.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">as</span> p <span class="keyword">JOIN</span> height_grades <span class="keyword">as</span> h</span><br><span class="line"><span class="keyword">ON</span> height <span class="keyword">BETWEEN</span> h.height_lowest <span class="keyword">AND</span> h.height_highest</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询身高介于1.90m到2.08m之间的名字，身高，以及对应的身高等级</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player_height_grades <span class="keyword">WHERE</span> height &gt;= <span class="number">1.90</span> <span class="keyword">AND</span> height &lt;= <span class="number">2.08</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务的特性(<code>ACID</code>)是：要么全部成功，要么全部失败。这保证了数据的一致性和可恢复性，它保证了我们在增加，删除，修改的时候某一个环节出错也能回滚还原。</p>
<p>Oracle是支持事务的，在MYSQL中，InnoDB才支持事务，可以通过<code>SHOW ENGINES</code>查看哪些存储引擎支持事务</p>
<p>事务的流程控制语句：</p>
<ol>
<li>START TRANSACTION或BEGIN：显式开启一个事务</li>
<li>COMMIT：提交事务。提交事务之后，对数据库的修改是永久性的。</li>
<li>ROLLBACK或ROLLBACK TO [SAVEPOINT]：回滚事务，表示撤销当前所有没有提交的修改或回滚到某个保存点</li>
<li>SAVEPOINT：在事务中创建保存点，一个事务可以有多个保存点</li>
<li>RELEASE SAVEPOINT：删除某个保存点</li>
<li>SET TRANSACTION：设置事务的隔离级别</li>
</ol>
<p>需要注意的是，使用事务有两种，分别为隐式事务和显式事务。隐式事务实际上就是自动提交，Oracle不自动提交，需要手写COMMIT命令，而MYSQL自动提交</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set autocommit =0;  // 关闭自动提交</span><br><span class="line">mysql&gt; set autocommit =1;  // 开启自动提交</span><br></pre></td></tr></table></figure>

<p>在MYSQL默认情况下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">name</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SELECT</span> <span class="string">'关羽'</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SELECT</span> <span class="string">'张飞'</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SELECT</span> <span class="string">'张飞'</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>

<p>表中存在一条数据<code>关羽</code>，原因在于<code>name</code>为主键，插入第二条数据的name字段为<code>张飞</code>时，抛出异常，回滚到上一次事务提交点</p>
<p>MYSQL中<code>completion_type</code>参数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@completion_type = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">name</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">SET</span> @@completion_type = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SELECT</span> <span class="string">'关羽'</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SELECT</span> <span class="string">'张飞'</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SELECT</span> <span class="string">'张飞'</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>

<p>表中存在一条数据，原因在于<code>completion=1</code>相当于在提交之后，在下一行写下<code>BEGIN</code></p>
<ol>
<li>completion=0,默认情况，在我们执行COMMIT的时候提交事务，在执行下一个事务时，还需要START TRANSACTION或BEGIN来开启</li>
<li>completion=1，提交事务之后，相当于是执行了COMMIT AND CHAIN，也就是开启了一个链式事务，即当我们提交了事务之后会开启一个相同隔离级别的事务</li>
<li>completion=2，这种情况下COMMIT=COMMIT AND RELEASE，在我们提交之后会自动断开与服务器连接</li>
</ol>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>严格来讲，我们可以使用串行化的方式来执行每个事务，这就意味着每个事务相互独立，不存在并发的情况。在生产中，往往存在高并发情况，这时需要降低数据库的隔离标准来换取事务之间的并发数</p>
<p><strong>三种异常情况</strong></p>
<ol>
<li>脏读(DIRTY READ)：读到了其他用户还没提交的事务</li>
<li>不可重复读(Nnrepeatable Read)：对某数据进行读取，发现两次结果不同。这时由于有其他事务对这个数据进行了修改</li>
<li>幻读(Phantom Read)：事务A根据条件查询到了N条事务，但此时B事务更改了符合事务A查询条件的数据，事务A再次查询发现数据不一致</li>
</ol>
<p>针对不同的异常情况，SQL92设置了4中隔离级别</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交(READ UNCOMMITTED)</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>读已提交(READ COMMITTED)</td>
<td>禁止</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>可重复读(REPEATABLE READ)</td>
<td>禁止</td>
<td>禁止</td>
<td>允许</td>
</tr>
<tr>
<td>可串行化(SERIALIZABLE)</td>
<td>禁止</td>
<td>禁止</td>
<td>禁止</td>
</tr>
</tbody></table>
<p>读已提交属于RDBMS中常见的默认隔离级别(比如Oracle和SQL Server)，如果想要避免不可重复读和幻读，需要在SQL查询时编写带锁的SQL语句</p>
<p>可重复读，是MYSQL默认的隔离级别</p>
<h3 id="PYTHON操作MYSQL接口"><a href="#PYTHON操作MYSQL接口" class="headerlink" title="PYTHON操作MYSQL接口"></a>PYTHON操作MYSQL接口</h3><p>在此使用<code>pymysql</code>模块来操作mysql接口</p>
<p>connection可以对当前数据库的连接进行管理，它提供以下接口</p>
<ol>
<li>指定host，user，passwd，port，database等参数连接数据库</li>
<li>db.cursor()：创建游标</li>
<li>db.close():关闭连接</li>
<li>db.begin()：开启事务</li>
<li>db.commit()和db.rollback()：事务提交和回滚</li>
</ol>
<p>游标提供的接口：</p>
<ol>
<li><p>cursor.execute():执行sql语句</p>
</li>
<li><p>cursor.fetchone()：读取查询结果一条数据</p>
</li>
<li><p>cursor.fetchall()：读取查询结果全部数据，以元祖类型返回</p>
</li>
<li><p>cursor.fetchmany(n)：读取查询结果多条数据，以元祖类型返回</p>
</li>
<li><p>cursor.rowcount：返回查询的行数</p>
</li>
<li><p>cursor.close()：关闭游标。</p>
</li>
</ol>
<p>为了保证数据修改的正确，可用try..except…模式捕获异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  sql = <span class="string">"INSERT INTO player (team_id, player_name, height) VALUES (%s, %s, %s)"</span></span><br><span class="line">  val = (<span class="number">1003</span>, <span class="string">" 约翰 - 科林斯 "</span>, <span class="number">2.08</span>)</span><br><span class="line">  cursor.execute(sql, val)</span><br><span class="line">  db.commit()</span><br><span class="line">  print(cursor.rowcount, <span class="string">" 记录插入成功。"</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="comment"># 打印异常信息</span></span><br><span class="line">  traceback.print_exc()</span><br><span class="line">  <span class="comment"># 回滚  </span></span><br><span class="line">  db.rollback()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  <span class="comment"># 关闭数据库连接</span></span><br><span class="line">  db.close()</span><br></pre></td></tr></table></figure>

<h3 id="Python-ORM框架操作MYSQL"><a href="#Python-ORM框架操作MYSQL" class="headerlink" title="Python ORM框架操作MYSQL"></a>Python ORM框架操作MYSQL</h3><p>ORM(Object Relation Mapping),使用ORM框架的原因在于随着项目的增加，降低维护成本，且不用关系底层的SQL语句是如何写的，就可以像类或者函数一样使用。以下示例都基于<code>sqlalchemy</code></p>
<h4 id="初始化表结构"><a href="#初始化表结构" class="headerlink" title="初始化表结构"></a>初始化表结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, create_engine, Integer, Float</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"><span class="comment"># 创建对象的基类:Base = declarative_base()</span></span><br><span class="line"><span class="comment"># 定义User对象:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(Base)</span>:</span></span><br><span class="line"><span class="comment"># 表的名字:</span></span><br><span class="line">	__tablename__ = <span class="string">'player'</span></span><br><span class="line">    <span class="comment"># 表的结构: </span></span><br><span class="line">    player_id = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    team_id = Column(Integer) </span><br><span class="line">    player_name = Column(String(<span class="number">255</span>))   </span><br><span class="line">    height = Column(Float(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 初始化数据库连接:</span></span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost:3306/heros_data'</span>)</span><br><span class="line"><span class="comment"># 创建DBSession类型:</span></span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br><span class="line">session = DBSession()</span><br></pre></td></tr></table></figure>

<p>连接格式为<code>数据库类型+数据库连接框架://用户名：密码@host:port/数据库名</code></p>
<p><code>__tablename</code>指明了对应的数据库表名称</p>
<p>在 SQLAlchemy 中，我们采用 Column 对字段进行定义，常用的数据类型如下：</p>
<table>
<thead>
<tr>
<th>Integer</th>
<th>整数型</th>
</tr>
</thead>
<tbody><tr>
<td>Float</td>
<td>浮点型</td>
</tr>
<tr>
<td>Decimal</td>
<td>定点类型</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔类型</td>
</tr>
<tr>
<td>Date</td>
<td>datetime.date日期类型</td>
</tr>
<tr>
<td>Time</td>
<td>datetime.date时间类型</td>
</tr>
<tr>
<td>String</td>
<td>字符类型，使用时需指明长度</td>
</tr>
<tr>
<td>Text</td>
<td>文本类型</td>
</tr>
</tbody></table>
<p>除了数据类型之外，也可以指定Column参数</p>
<table>
<thead>
<tr>
<th>default</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>primary_key</td>
<td>是否为主键</td>
</tr>
<tr>
<td>unique</td>
<td>是否唯一</td>
</tr>
<tr>
<td>autoincrement</td>
<td>是否自增</td>
</tr>
</tbody></table>
<h4 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增一行数据</span></span><br><span class="line">new_player = Player(team_id=<span class="number">1002</span>, player_name=<span class="string">'唐潇唐'</span>, height=<span class="number">1.71</span>)</span><br><span class="line">session.add(new_player)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将球员身高为2.08的全部改为2.09</span></span><br><span class="line">rows = session.query(Player).filter(Player.height == <span class="number">2.08</span>).all()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rows:  </span><br><span class="line">	i.height = <span class="number">2.09</span></span><br><span class="line">session.commit()session.close()</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row = session.query(Player).filter(Player.player_name==<span class="string">'约翰 - 科林斯'</span>).first()</span><br><span class="line">session.delete(row)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>query(Player)相当于是<code>select *</code>,这时可以对player表中所有字段进行打印</p>
<p>filter()函数相当于是<code>WHERE</code>条件查询 </p>
<p>多条件查询时，比如查询身高大于等于2.08，小于等于2.10的球员</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows = session.query(Player).filter(Player.height &gt;=<span class="number">2.08</span>, Player.height &lt;=<span class="number">2.10</span>).all()</span><br></pre></td></tr></table></figure>

<p>使用or查询时，需要引入<code>or_</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> or_</span><br><span class="line">rows = session.query(Player).filter(or_(Player.height &gt;=<span class="number">2.08</span>, Player.height &lt;=<span class="number">2.10</span>)).all()</span><br></pre></td></tr></table></figure>

<p>分组查询，排序，统计等需要引入<code>func</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">rows = session.query(Player.team_id, func.count(Player.player_id)).group_by(Player.team_id).having(func.count(Player.player_id)&gt;<span class="number">5</span>).order_by(func.count(Player.player_id).asc()).all()</span><br><span class="line">print(rows)</span><br></pre></td></tr></table></figure>

<p>关于条件查询更多的接口，可以查看<code>filter</code>方法和<code>func</code>方法的源码目录</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="唐潇唐">
  
  <p class="site-author-name" itemprop="name">唐潇唐</p>
  <div class="site-description motion-element" itemprop="description">进击的测试</div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
  </nav>



  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>





  <div class="links-of-author motion-element">
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:tangxiao.work@gmail.com" title="E-Mail &rarr; mailto:tangxiao.work@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>E-Mail</a>
      </span>
    
  </div>







          
          
        </div>
      </div>

      

      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">唐潇唐</span>

  

  
</div>









        








        
      </div>
    </footer>

    

    

    

    

  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


















  
  



  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>







  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  

















  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>














<script>
// GET RESPONSIVE HEIGHT PASSED FROM IFRAME

window.addEventListener("message", function(e) {
  var data = e.data;
  if ((typeof data === 'string') && (data.indexOf('ciu_embed') > -1)) {
    var featureID = data.split(':')[1];
    var height = data.split(':')[2];
    $(`iframe[data-feature=${featureID}]`).height(parseInt(height) + 30);
  }
}, false);
</script>








  
  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>

  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  
  <script type="text/javascript" opacity="0.7" zindex="-2" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
